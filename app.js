require('dotenv').config();
const express = require('express');
const { exec } = require('child_process');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const path = require('path');

const { getEasternTime } = require('./utils');  // Adjust the path as necessary based on your file structure
const app = express();
const port = 8087;
const users = {
    admin: {
      username: "admin",
      // This is a hashed password generated by bcrypt
      password: process.env.ADMIN_PASSWORD_HASH
    }
  };
  const authenticateJWT = (req, res, next) => {
    const authHeader = req.headers.authorization;
  
    if (authHeader) {
      const token = authHeader.split(' ')[1];
  
      jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) {
          return res.sendStatus(403);
        }
  
        req.user = user;
        next();
      });
    } else {
      res.sendStatus(401);
    }
  };

  

  app.get('/', (req, res) => 
{
    res.sendFile(path.join(__dirname, 'public', 'login.html'));
  });
app.use(express.static('public')); // Serve static files from 'public' directory
// Serve static files from 'assets' directory
app.use('/assets', express.static('assets'));
app.use(express.json()); // Parse JSON bodies

let serverRunning = false; // Variable to track the server state
app.get('/status', (req, res) => {
    res.json({ running: serverRunning });
  });
// Start the Minecraft server
app.post('/start', authenticateJWT, (req, res) => {
    const subprocess = exec(`sh ${process.env.START_COMMAND_PATH}`);
  
    subprocess.stdout.on('data', (data) => {
      console.log(`stdout: ${data}`);
    });
  
    subprocess.stderr.on('data', (data) => {
      console.error(`stderr: ${data}`);
    });
  
    subprocess.on('error', (error) => {
      console.error(`exec error: ${error}`);
      res.status(500).send('Failed to start the server');
    });
  
    // Send a response back immediately after starting the server
    serverRunning = true; // Set to true when server starts
    res.send('Server start command executed');
    console.log(`Server start command executed at ${getEasternTime()}`);
  });
  
// Stop the Minecraft server
app.post('/stop', (req, res) => {
    // Sends the "stop" command to the Minecraft server running in a screen session
    exec('screen -S MinecraftSession -p 0 -X stuff "stop"$(printf "\\r")', (error, stdout, stderr) => {
        if (error) {
          console.error(`exec error: ${error}`);
          return res.status(500).send('Failed to stop the server');
        }
        serverRunning = false; // Set to false when server stops
        res.send('Server stop command issued successfully');
        console.log(`Server stop command executed at ${getEasternTime()}`);
      });
  });
  app.post('/login', async (req, res) => {
    const { username, password } = req.body;
  
    // Check if the user exists
    const user = users[username];
    if (user) {
      // Compare hashed password
      const match = await bcrypt.compare(password, user.password);
      if (match) {
        // Create and assign a token
        const token = jwt.sign({ username: user.username }, process.env.JWT_SECRET, { expiresIn: '1h' });
        res.json({ message: "Authentication successful!", token });
      } else {
        res.status(401).send("Invalid Credentials");
      }
    } else {
      res.status(401).send("User does not exist");
    }
  });
app.listen(port, () => {
  console.log(`Server listening at http://localhost:${port}`);
});


