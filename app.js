require('dotenv').config();
const express = require('express');
const { exec, execSync, spawn } = require('child_process');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const path = require('path');
const fs = require('fs');
const WebSocket = require('ws');  // Import the WebSocket library
const recursive = require('recursive-readdir');
let wss;

const { getEasternTime, getFormattedDate, getEasternDateHour } = require('./utils');  // Adjust the path as necessary based on your file structure
const app = express();
const port = 8087;
const users = {
  admin: {
    username: "admin",
    // This is a hashed password generated by bcrypt
    password: process.env.ADMIN_PASSWORD_HASH
  }
};
const authenticateJWT = (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (authHeader) {
    const token = authHeader.split(' ')[1];

    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
      if (err) {
        return res.sendStatus(403);
      }

      req.user = user;
      next();
    });
  } else {
    res.sendStatus(401);
  }
};



app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'login.html'));
});
app.use(express.static('public')); // Serve static files from 'public' directory
// Serve static files from 'assets' directory
app.use('/assets', express.static('assets'));
app.use(express.json()); // Parse JSON bodies

let serverRunning = false; // Variable to track the server state
let lastBackupHour = null;
app.get('/status', (req, res) => {
  res.json({ running: serverRunning });
});
// Start the Minecraft server
app.post('/start', authenticateJWT, (req, res) => {
  const subprocess = exec(`sh ${process.env.START_COMMAND_PATH}`);

  subprocess.stdout.on('data', (data) => {
    console.log(`stdout: ${data}`);
  });

  subprocess.stderr.on('data', (data) => {
    console.error(`stderr: ${data}`);
  });

  subprocess.on('error', (error) => {
    console.error(`exec error: ${error}`);
    res.status(500).send('Failed to start the server');
  });

  // Send a response back immediately after starting the server
  serverRunning = true; // Set to true when server starts
  res.send('Server start command executed');
  console.log(`Server start command executed at ${getEasternTime()}`);
});

// Stop the Minecraft server
app.post('/stop', authenticateJWT, (req, res) => {
  // Sends the "stop" command to the Minecraft server running in a screen session
  exec('screen -S MinecraftSession -p 0 -X stuff "stop"$(printf "\\r")', (error, stdout, stderr) => {
    if (error) {
      console.error(`exec error: ${error}`);
      return res.status(500).send('Failed to stop the server');
    }
    serverRunning = false; // Set to false when server stops
    res.send('Server stop command issued successfully');
    console.log(`Server stop command executed at ${getEasternTime()}`);
  });
});
app.post('/restart', authenticateJWT, (req, res) => {
  if (!serverRunning) {
      res.status(400).send('Server is not currently running.');
      return;
  }
  // Sends the "stop" command to the Minecraft server running in a screen session
  exec('screen -S MinecraftSession -p 0 -X stuff "stop$(printf "\\r")"', (error, stdout, stderr) => {
      if (error) {
          console.error(`exec error: ${error}`);
          res.status(500).send('Failed to stop the server');
          return;
      }

      console.log(`Server stop command executed at ${getEasternTime()}`);
      serverRunning = false; // Update the server running status

      // Wait for 3 seconds before starting the server again
      setTimeout(() => {
          startServer();
          res.send('Server is being restarted'); // Inform the client that the restart process has been initiated
      }, 3000);
  });
});
app.post('/login', async (req, res) => {
  const { username, password } = req.body;

  // Check if the user exists
  const user = users[username];
  if (user) {
    // Compare hashed password
    const match = await bcrypt.compare(password, user.password);
    if (match) {
      // Create and assign a token
      const token = jwt.sign({ username: user.username }, process.env.JWT_SECRET, { expiresIn: '1h' });
      res.json({ message: "Authentication successful!", token });
    } else {
      res.status(401).send("Invalid Credentials");
    }
  } else {
    res.status(401).send("User does not exist");
  }
});

// Backup Minecraft server
app.post('/backup', authenticateJWT, async (req, res) => {
  const now = new Date();
  const currentHour = getEasternDateHour();

  if (lastBackupHour === currentHour) {
    return res.status(403).send('A backup has already been performed this hour.');
  }

  let wasServerRunning = serverRunning; // Store the state of the server
  if (serverRunning) {
    execSync('screen -S MinecraftSession -p 0 -X stuff "stop$(printf "\\r")"');
    serverRunning = false;
    console.log(`Server stopped for backup at ${getEasternTime()}`);
    setTimeout(() => performBackup(currentHour, now, wasServerRunning, res), 3000)
  }
  else {
    setTimeout(() => performBackup(currentHour, now, wasServerRunning, res), 5)
  }
});
// Utility function to calculate directory size
function calculateDirectorySize(directoryPath) {
  return new Promise((resolve, reject) => {
      // Define an array of patterns or filenames to ignore
      const ignoreFiles = [
          '.zsh_sessions', 
          '.bash_history', 
          '.zsh_history', 
          // Include patterns to ignore any hidden files or specific directories if necessary
          '.*', // Ignores all hidden files (files starting with a dot)
          '**/node_modules/**' // Ignores all node_modules directories
      ];

      recursive(directoryPath, ignoreFiles, (err, files) => {
          if (err) {
              reject(err);
          } else {
              let totalSize = 0;
              files.forEach(file => {
                  try {
                      totalSize += fs.statSync(file).size;
                  } catch (err) {
                      console.error(`Error accessing file ${file}: ${err}`);
                      // Optionally handle errors, e.g., permission issues or file not found, without throwing
                  }
              });
              resolve(totalSize);
          }
      });
  });
}
// Function to handle the backup process
function performBackup(currentHour, now, wasServerRunning, res) {
  try {
    const dateFolder = getFormattedDate(now);
    const hourLabel = now.getHours() >= 12 ? `${(now.getHours() % 12) || 12} PM` : `${now.getHours()} AM`;
    const backupPath = `${process.env.BACKUP_PATH}/${dateFolder}/${hourLabel}`;
    fs.mkdirSync(backupPath, { recursive: true });

    // Call calculateDirectorySize and wait for the result before starting rsync
    calculateDirectorySize(process.env.MINECRAFT_SERVER_PATH)
    .then(totalSize => {
      let totalTransferred = 0; // Initialize the total transferred bytes

      const rsync = spawn('rsync', [
        '-avh',
        '--info=progress2',
        '--out-format=%n %l %b', // Custom format: filename, total size, bytes transferred
        '--exclude', '.zsh_sessions',
        '--exclude', '.bash_history',
        '--exclude', '.zsh_history',
        `${process.env.MINECRAFT_SERVER_PATH}`,
        `${backupPath}`
      ]);


      rsync.stdout.on('data', (data) => {
        const progressData = data.toString();
        console.log(progressData); // Log the raw data for debugging

        // Match the custom output format for transferred bytes
        const match = progressData.match(/[\w\.\-]+ (\d+) (\d+)/);

        if (match) {
          const fileSize = parseInt(match[1], 10);
          const transferredBytes = parseInt(match[2], 10);

          totalTransferred += transferredBytes;

          // Calculate the overall progress
          const progress = Math.min(Math.round((totalTransferred / totalSize) * 100), 100);
          console.log(`Broadcasting progress: ${progress}%`);
          broadcastProgress({ type: 'progress', value: progress });
        }
      });

        rsync.stderr.on('data', (data) => {
          console.error(`rsync stderr: ${data.toString()}`);
        });

        rsync.on('close', (code) => {
          if (code === 0) {
            console.log(`Backup performed successfully at ${getEasternTime()}`);
            res.send('Backup performed successfully');
            lastBackupHour = currentHour;
            if (wasServerRunning) {
              startServer();
            }
          } else {
            console.error(`Backup failed with exit code: ${code}`);
            res.status(500).send('Failed to perform backup');
          }
        });

      }).catch(err => {
        console.error(`Error calculating directory size: ${err}`);
        res.status(500).send('Failed to calculate directory size for backup');
      });

  } catch (error) {
    console.error(`Backup failed: ${error}`);
    res.status(500).send('Failed to perform backup');
  }
}
// Additional function to start the server if it was running before
function startServer() {
  exec(`sh ${process.env.START_COMMAND_PATH}`, (error) => {
    if (error) {
      console.error(`Error starting the server: ${error}`);
    } else {
      serverRunning = true;
      console.log(`Server restarted after backup at ${getEasternTime()}`);
    }
  });
}
// Broadcasts progress data to all connected WebSocket clients
function broadcastProgress(message) {
  const data = JSON.stringify(message);
  wss.clients.forEach(function each(client) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(data);
    }
  });
}
const server = app.listen(port, () => {
  console.log(`Server listening at http://localhost:${port}`);
  // Attach WebSocket server to the same HTTP server
  wss = new WebSocket.Server({ server });

  wss.on('connection', function connection(ws) {
    console.log('Client connected to WebSocket.');

    // Add any message handlers or other WebSocket-related code here
  });
});


